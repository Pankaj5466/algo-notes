\chapter{Dynamic Programming}\label{chp:dynamic_programming}

% \lipsum[100]
% \blindtext[10]


The word \textbf{Dynamic} in Dynamic Programming refers that our computation complexity for the given problem can be reduced if:

\begin{enumerate}[(i)]
    \item Current state of the problem depends upon previous state solved.
    \item previous state has been already precomputed \& we have also saved their state.
\end{enumerate}


As we know recursion is way, in which current problem can be expressed in term of smaller sub-problem. Hence, writing the current state of problem in recursive way is the main step in solving question by dynamic programming.

\vspace{5mm}
% \addvspace{10cm}
Steps to Solve Dynamic Programming Question:
\begin{enumerate}[(i)]
    \itemsep0em 
    \item Express the current state of problem in recurrance relation.
    \item solve the problem in recursive way. (by considering all the edge case).
    \item Compute time complexity of recursive solution. Then compute time complexity of memoized solution.
    \item If memoized time complexiy is okay $\Rightarrow$ this is the solution.
    \item If memoized time compleixy is not okay $\Rightarrow$ express solution in alternative recurrance (same as modifying the recursive function defination) way; such that less variable term are mentioned in the recurrance relation.
\end{enumerate}

\section*{Dynamic Programming Questions}
\paragraph{type1} We will list \& discuss some of the common question pattern from this paradigm.

\part{Inclusion-Exclusion}
\input{subset-sub.tex}
\input{coin-change.tex}
\input{rod-cutting.tex}
\part{Ways at idx}
\input{matrix-multiplication.tex}

\part{Subsequence}
\input{lcs.tex}
\input{edit-distance.tex}
\input{lis.tex}
\input{lps.tex}

\part{Subarray Problem}
\input{lisa.tex}
\input{lc2771.tex}
\input{lpsa.tex}


\begin{exercise}
    \begin{enumerate}
    \item (LC 1547) Minimum cost to cut a stick.
    \item  For LC1547 print the optimal ordering.
    \item 
    LC 2218 : $f(idx,\_)$ = maximum total value of coing we can pick if we are allowed to pick coins from from arr[0...idx]\\
    now at idx, we have the option to chose either \begin{verbatim} {1}, {1,2}, {1,2,3}... {1,2,...min(k,size)} \end{verbatim} options
       
    we will take the best from all the option.
   
    \item LC 1105: with $f(idx,\_)$ defination as same as 2218.\\
    At idx, we can chose either 1 or 2 or 3 books, ... n books. We will take the best of all.

    \item LC 1547 (simple variation of rod-cutting)
    \item LC 1092- Shortest Common Supersequence
    \item LC801 Minimum Swaps To Make Sequences Increasing 
    \item LC139 Word Break\\ Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
    \item SEPERATOR (Please Categorize)
    \item 
    LC 2218 : $f(idx,\_)$ = maximum total value of coing we can pick if we are allowed to pick coins from from arr[0...idx]\\
    now at idx, we have the option to chose either \begin{verbatim} {1}, {1,2}, {1,2,3}... {1,2,...min(k,size)} \end{verbatim} options
       
    we will take the best from all the option.
   
    \item LC 1105: with $f(idx,\_)$ defination as same as 2218.\\
    At idx, we can chose either 1 or 2 or 3 books, ... n books. We will take the best of all.

    \item LC 1547 (simple variation of rod-cutting)
    \item LC 1092- Shortest Common Supersequence
    \item LC801 Minimum Swaps To Make Sequences Increasing 
    \item LC139 Word Break\\ Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
\end{enumerate}


    { \Large Palindrome Pattern \\}
    In this pattern, range is decided by arr[l..r]. Or arr[0..l] for some case.
    \begin{enumerate}
        \item (LC131) Palindrome Partioning \\Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. 
        \constrain{s.lenght<=16, s[i] \in [a,z]}
        
        \item (LC132) Palindrom Paritioning II \\ For above question, return minimum cuts needed to perform the operation.
        \constrain{s.lenght\leq2000,s\in[a-z]}

        \item (LC1216) Valid Palindrome \\A string is k-palindrome if it can be transformed into a palindrome by removing at most k characters from it. Given a string s and an integer k, return true if s is a k-palindrome.
        \constrain{s.lenght \leq 1000, k \leq s.length, s \in [a-z]}

        \item (LC1246) Palindrome Removal\\ You are given an integer array arr.
        In one move, you can select a palindromic subarray \verb|arr[i], arr[i + 1], ..., arr[j] where i <= j|, and remove that subarray from the given array.
        Return the minimum moves to remove all element from the array.
        \constrain{arr.length \leq 100, arr[i] \in [1,20]}

        \item (LC1147) Longest Chunked Palindrome Decomposition \\You are given a string text. You should split it to k non-empty substrings (subtext1, subtext2, ..., subtextk) such that:
        $subtexti == subtextk - i + 1$ for all valid values of i.
        Return the largest possbile value of k.
        \constrain{text.lengt \leq 1000}

        \item (LC1278) Palindrom Paritioning III \\You are given string s and integer k. You need to divide s into k substring,such that each substring is palindrome. Return the minimum character change you require to complete the task. (Similar LC1312,LC1745)
        \constrain{s,k \leq 100}

        \item (LC1771) Maximize Palindrome Length From Subsequences\\ You are given two strings, word1 and word2. You want to construct a string in the following manner:
        Choose some non-empty subsequence subsequence1 from word1.
        Choose some non-empty subsequence subsequence2 from word2.
        Concatenate the subsequences: subsequence1 + subsequence2, to make the string.
        Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0.
        \constrain{array.size \leq 1000}

        \item (LC2472)  Maximum Number of Non-overlapping Palindrome Substrings\\You are given a string s and a positive integer k.

        Select a set of non-overlapping substrings from the string s that satisfy the following conditions:
        
        The length of each substring is at least k.
        Each substring is a palindrome.
        Return the maximum number of substrings in an optimal selection.
        \constrain{s.length \leq 2000}

        {\Large Palindromic Count Problems}

        \item (LC730) Count Different Palindromic Subsequences
       


    \end{enumerate}

\end{exercise}

\begin{exerciseHints}[Solutions/Comments:]
    % Comment About Excercise Problem (And possibly have hint too)
    \begin{enumerate}
        \item LC801: Nice problem where state information can be transferred to other variable + if we use base case to detect invalid case, then code can be greatly simplified.
        \item LC139 Word Break \\Give (a) f(idx,\_) solution (b) f(l,r,\_) solution (c) BFS Solution (d) Trie Solution
    \end{enumerate}

    { \Large Palindrome Pattern(almost all dp pattern here) \\}
    \begin{enumerate}
        \item (LC131) Palindrome Partioning \\As the constrain is less, can you backtract all possible combination? Let \verb|f(idx):=| generate the answer when you are given \verb|arr[idx:]| only.
        
        \item (LC132) You can try brute forcing, but now as the constrain reqirement suggest us to use $O(n^2)$ algorithm.
        
        Let \verb|f(l,r):=| minimum cut needed to partion all substring as plaindrome, when you are allowed to use \verb|arr[l..r]| only. Then for each \verb|f(l,r)| you can try cutting at all places and take the best of cost.
        Explain why the complexity is $O(n^2)$ even though we haved used two variable l and r. And we are splittin at all k places also.
        
        If you think your recursive function defination as \verb|f(idx):=| minimum cut need when you are allowed to use \verb|arr[idx:]| only. Then at each idx, you can try to form a substring \verb|s[idx:k]|. If this substring is itself a plaindrome, the problem to \verb|f(k)|.

        There exist other approach, expand around the center. Can you write the code for all 3 above approaches?

        \item (LC1216) Valid Palindrome\\ Try to solve it just like you have solved Edit Distance. Start with l and r pointer, if both equal then no cost to delete. if equal then try deleting left, then right.
        take minimum cost from all three operation.

        LCS way:Alternative approach is to reverse the given string and find maximum subsequence length between the two. The string is k-palindromic if the difference between the string length and subsequence length is not more then k.
        
        \item (LC1246) Palindrome Removal \\Key Observation: A[i] can be deleted either alone or can make a pair. Now in normal \verb|palindrome length| calculation, we make A[l] pair with A[r] (A[r] is first occurrance from right side for arr[l..r]). But, in current case A[i] can me made to pair with all ch which occurr at any index.
        (this is tough question to formulate the subproblem, leave it for now.)
        
        \includegraphics[width=\marginparwidth]{./resources/LC1246_p1.jpg}

        \item (LC1147) Straight implemention of the question will pass the tc.
        
        \item LC1278 Palindrom Paritioning III \\ Can you think in term of edit distance.
        
        \item (LC1771) Maximize Palindrome Length From Subsequences\\ After s = s1+s2. You can easily find the longest palindrome from s when there is not restriction to pick character.
        Now with restriction, how can you be sure that you pick at least one character from each one of them?

        To must take at least one character from both. we can find the palindromic length of cases for which s1[i] = s2[j] only.

Question: What about case when this character (s1[i]==s2[i]:= ch) is not taken and longest subsequence if formed without this??

Analysis: This case won't happen. As we are picking up the subsequence. We must take this character as it will always add +2 to our answer.

    \item (LC2472) Try using palindromic subarray + jump game. (.cpp file available)

        
    \end{enumerate}
    
\end{exerciseHints}