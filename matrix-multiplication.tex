\begin{problem}{Matrix Chain Multiplication}
    Given a sequence of matrices, find the most efficient way to multiply these matrices together. The efficient way is the one that involves the least number of multiplications.
    The dimensions of the matrices are given in an array arr[] of size N (such that N = number of matrices + 1) where the ith matrix has the dimensions (arr[i-1] x arr[i]).
    \href{https://practice.geeksforgeeks.org/problems/matrix-chain-multiplication0303/1}{Pratice Link}
\end{problem}

\begin{solution}
    let $f(idx,_):= $ multiplication cost when we are allowed to multipliy arr[0...idx] \textbf{only}.
    Now at index idx, we want to include the arr[idx] in our solution range \& we already know answer of arr[0...idx-1].

    Hence, at idx we have the following option:
    \textit{can you think of recursive way as, how can we find the solution of $f(idx)$ using subproblem??}

    One way is that we try every possible split: 
    split at 1, split at 2, split at 3 
    y

    % TO-DO:show below code in time
    $ val_k =( leftCost * arr[k] * rightCost )$

    
    $ val_k = f(k)*arr[k]* f(k...idx) $
    
    As you can see for rightCost calculation we need range 
    But our function can only give $f(0..idx)$.  which we usually shorthand for $f(idx)$.

    if you could devise a way to find rightCost, then we can find the answer with above function signature.


\end{solution}

\begin{solution}
    As we see f(0..idx) (also represented a f(idx)) was not sufficent to able to find our answer.
    and we needed a range of l \& r.

    let follow up on that, and define our updated recurrance relation as:
    $f(l,r,_):=$ multiplication cost when we are allowed to multiply in range arr[l..r] \textbf{only}
\end{solution}

\begin{solution}
    This is another important patter of dp. 
    In this, generally the size of array be such that we require $O(n^3)$ time complexiy to solve the question.
    
    % TO-DO: fix the marginote overflow issue
   \begin{marginnote}
    The $O(n^3)$ complexity of problem itself suggest that you should try this solution.
   \end{marginnote}

   \vspace{2mm}
   Here, instead of considering our question space to be [0..idx], we will consider it to be [l...r].


   And after that we will try to find our the number of ways can fill the carr[idx].

   \vspace{2mm}
   For the given problem, if we have the array at arr[l..r] and we need to find the optimal cost to multiply.
   Then we will try all possible way to multiply the matrix \& take the best amount them.
   
   \begin{verbatim}
        int matrixChainMultiplicatino(int l, int r, const vector<int>&arr)
        {
            if(l>=r)
                return 0; //no element exist in arrr

            int bCost = INT_MAX; //best cost
            
            //Try out all possible place
            for(int k=l;k<r;k++)
            {
                int leftCost =  matrixChainMultiplicatino(l,k,arr);
                int rightCost = matrixChainMultiplicatino(k+1,r,arr);

                cc printf("(%d,%d):: LeftCost = %d, RightCost = %d\n",l,r,leftCost,rightCost);

                int splittingCost = (arr[l-1] * arr[k] * arr[r]) + leftCost + rightCost;

                bCost = min(bCost,splittingCost);
            }
        //  printf("Best Cost to Multiply %d = %d\n",l,bCost);
            return bCost;
        }
   \end{verbatim}

\end{solution}

\begin{solution}
    //TO-DO: Complete this
    what if f(idx) := optimal multiplication cost when we have allowed only matrix arr[0...idx]

    for sarr[idx], the cost will depedent upon ??
\end{solution}
    