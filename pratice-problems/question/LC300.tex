\begin{problem}{LC300 LIS}
    Given an integer array nums, return the length of the longest strictly increasing subsequence. LC 300\\
    (a)Give $O(n^2)$ algorithm.\\
    (b)Give $O(n*log(n))$ algorithm.

    \footnotetext{Pratice Link: \href{https://leetcode.com/problems/maximum-subarray/}{LC53}}
    \footnotetext{Solution File: ./resources/subarray-sum.cpp}
\end{problem}


% TO-DO: Add new environment for hints.
\begin{hints}
    Try to think of the the problem in terms of...
\end{hints}


% \newcommand{\computeSum}{
% %   \immediate\write18{awk '{sum += $0} END {print sum}' data.txt > sum.txt}
% \immediate\write18{node test.js > output.txt}
%   \input{sum.txt}
% }

\immediate\write18{node test.js > output.txt}


% \immediate\write18{echo '100\percentchar' > hash.tex}







% \begin{solution}[Inclusion-Exclusion]
%     \vspace{2mm}
%     \hrule
%     \vspace{2mm}

%     Standard recursive solution.
%     let $f(idx,\_)$:= maximum lis length when we are allowed to chose element from [0...idx] \textbf{only}.

%     \medskip
%     Considerting we have answer for our subproblem.\\
%     Then at index idx, we can fill up sarr[idx] in following ways:\\
%     (a) pick arr[idx] if it satify the constrain\\
%     (b) do not pick arr[idx]\\

%     \begin{verbatim}
%         int findAns(int idx,int last,vector<int> &sarr,const vector<int>&arr)
%         {
%             if(idx >= arr.size())
%                 return 0;
            
%             /* for analysing the solution being created*\
%     cc        printf("\t::[%d]: last(%d)\t",idx,last);
%     cc        for(auto k:sarr) cout<<k<<" ";
%     cc        cout<<endl;
                  
%             int inc = 0; //Explain: why inc=1 is not the defult value?
%             int exc = 0;
            
%             if(last < arr[idx])
%             {
%                 sarr.push_back(arr[idx]);
%                 inc = 1 + findAns(idx+1,arr[idx],sarr,arr);
%                 sarr.pop_back();
%             }
            
%             exc = findAns(idx+1,last,sarr,arr);   
%             /* for analysing the optimal option to chose at index idx*/    
%     cc      printf("[%d]:(%d,%d)\n",idx,inc,exc);
            
%             return max(inc,exc);           
%         }
%     \end{verbatim}

%     Follow-Up Question:\\
%         (a) In case last in very big, how will you modify your solution so that its memoization is within time limit? (sol: see findAnsTwo)\\
%         (b) Modify the solution of (a) and shift the invalid detection condition to recursion base condition. (sol: findAnsThree)

% \end{solution}